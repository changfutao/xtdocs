# 线性数据结构

## 1.抽象概念

> 线性表: 有序序列,  是一种有序的放元素的容器。【有序表示有编号并且有索引】

## 2.物理实现

### 2.1 内存中怎么表达该序列

> 内存是线性编址的,内部把存储单元小格子编号

## 3.实现方式

### 3.1 顺序表

> 使用连续的内存单元存储该序列的所有元素,内存的顺序就是数据顺序

数组是顺序表的一种表现形式,它在内存中开辟连续的内存空间,变量指向顺序表的第一个元素地址(首地址), 容器占用的内存称为容量(cap), 可以最多容纳多少个元素, 当前容器目标的元素个数称为长度len

```go
// 变量arr 这个标识符指向数组首地址
var arr = [3]int{22, 33, 55} 
```

注意: 顺序Sequence,排序是sort, 这里说的是顺序表

- Create
  - 容器元素个数+1
  - append如同排队,在队尾后增加即可
  - insert插队
    - 队伍最后插入, 就是append
    - 中间插队, 占用当前位置, 把当前位置与其后所有数据后移
    - 队首插队, 所有元素统统后移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大
- Delete
  - 容器元素个数-1
  - pop队尾元素移除,影响最小
  - remove移除
    - 队尾移除, 就是pop
    - 中间移除,后面数据统统前移
    - 队首移除, 所有数据统统前移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大

- Update
  - 元素个数不变
  - 定位问题
  - 更新内容

- Read
  - 定位问题
    - 使用索引, 首地址 + 该类型的占用的字节数 * 偏移数, 所以定位要用索引计算得到的内存地址,不需要遍历, 效率很高
    - 如果使用内容定位, 内容比较, 遍历的方式是挨个元素比较内容,最好的情况是第一个元素就是需要的, 最不好的情况是, 每个元素都比较了一遍,但是没有找到想要的

  - 获取内容: 使用索引直接定位该位置拿走内容
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍【从首地址开始,挨个偏移取内容】


> 顺序表适合仅仅在尾部增删, 还有扩容问题

#### 3.1.1 数组

> 数组: 容器不可变【容器的元素个数不能变】,数组必须给出长度,以后这个数组就不能增删元素【不能扩容】,数组定义的时候必须给出长度

- 数组是值类型,每次赋值都会做副本拷贝【复制】
  - 数组是值类型,值类型完全复制
  - 用它给别的标识符赋值,会复制
  - 函数传入参数时,会复制
  - 函数返回值用数组,会复制
- 通过索引来定位,从0开始
- 内存结构
  - 数组地址就是数组第一个元素的地址
  - 每个元素占用空间看元素类型,int动态类型【看CPU架构32/64 => 4/8】
  - 一个元素占用几个字节和类型有关,第一个元素的存储单元后面一定是第二个元素的存储单元

字符串字面量一旦定义不可改变,不同的字符串长度不一,数组存储string元素,测试发现元素存储空间间隔一样,都是16字节,说明字符串比较复杂，16个字节里面放了一个指针,指向字符串的内存位置。

数组里的元素不能增删,但是数组里的元素给更改【只能给改为同类型的】

```go
// 1.定义一个长度为5的数组类型, 注意: [3]int 与 [5]int这两个不是同一个类型
var a1 = [5]int{5, 3, 11, 21, 2}
```



### 3.2 链接表

> 每一个元素存储在内存中,但是元素并不是连续的存储在内存中,散落在内存的不同位置,前一个元素指向下一个元素【双向链表中,下一个元素也会指向上一个元素】(链接)【简称链表】可以理解为手拉手

链表是个容器,可以放元素,定义一个变量指向链表第一个元素地址即可(首地址), 在链表中会定义一个首部(head)和尾部(tail)的地址

cap是指当前放了多少个元素,和len一致的,不需要提前开辟内存空间

链表可以分为单向和双向

- 单向	前一个元素指向下一个元素
- 双向    前一个元素指向下一个元素,下一个元素指向上一个元素

列表List往往是链表的表现形式【python除外】

- Create
  - 容器个数+1
  - 尾部插入,原来的尾部指向新尾部,容器需要改tail,没有数据挪动,很快
  - 中间插入,断开原来的链接,分别和新元素拉手,没有数据挪动,代价不大
  - 首部插入,原来的首部和新首部互指,容器需要改head,没有数据挪动, 代价不大
- Delete
  - 容器个数-1
  - 尾部删除, 容器重新定位tail,当前尾部的前一个成为新的tail,删除旧tail的元素
  - 中间删除,遍历定位,当前元素删除,前驱、后继拉手即可
  - 首部删除,容器重新定位head,当前head的下一个元素成为新的head,删除旧的head元素
- Update
  - 元素个数len不变
  - 定位问题
  - 更新内容
- Read
  - 定位问题
    - 使用索引, 由于元素散落在内存中,不能使用顺序表公式来定位,找到head依次遍历索引。按照遍历元素的方式来找的,但是取的每一个节点中保存的下一个地址,使用该地址定位下一个元素和顺序表比起来略慢, 但是由于使用地址效率还可以
    - 使用内容查找定位,需要遍历查找,效率低下
  - 获取内容: 
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍

> 链接表适合规模大的对数据进行增删,不需要扩容,新增时找到一个位置放当前元素即可,修改指向(链接地址)



**注意: 二分法查找有一个前提,就是已经为元素排过序了,而排序非常耗时,非必要不要做排序**







