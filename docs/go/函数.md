# 函数

## 1.数学定义

- y=f(x), y是x的函数,x是自变量,y=f(x0, x1, ...,xn)

## 2.Go函数

- 由若干语句组成的语句块、函数名称、参数列表、返回值构成,它是组织代码的最小单元
- 完成一定的功能

## 3.函数的作用

- 结构化编程对代码的最基本的封装,一般按照功能组织一段代码
- 封装的目的为了复用,减少冗余代码
- 代码更加简洁美观、可读易懂

## 4.函数的分类

- 内建函数,如make、new、panic等
- 库函数,如math.Ceil()等
- 自定义函数、使用func关键字定义

## 5.函数定义

```go
func 函数名(参数列表) [(返回值列表)] {
    函数体(代码块)
    [return 返回值]
}
这里[]表示其中的内容可有可无
```

- 函数名就是标识符,命名要求一样
- 定义中的参数列表称为形式参数,只是一种符号表达(标识符),简称形参
- 返回值列表可有可无,需要return语句配合,表示一个功能函数执行完返回的结果
- 函数名(参数列表)[(返回值列表)]这部分称为函数签名
- Go语言中形参也被称为入参,返回值也被称为出参

## 6.函数调用

- 函数定义,只是声明了一个函数,他不能被执行,需要调用执行
- 调用的方式,就是函数名加上小括号,如有必要在括号内填写上参数
- 调用时写的参数是实际参数,是实实在在传入的值,简称实参,这个过程称为传实参,简称传参
- 如果定义了返回值列表,就需要配合使用return来返回这些值

```go
// 函数定义
// x、y是形式参数,result是返回值
func add(x, y int) int {
    result := x + y // 函数体
    return result //返回值
}

func main() {
    out := add(4, 5) // 函数调用,可能有返回值,使用变量接收这个返回值
    fmt.Println(out) // 对于Println函数来说,这也是调用,传入了实参out
    out = add(10, 11) // 请问,这次函数调用和上次有没有关系?
    fmt.Println(out) // 请问,函数定义了几次? 调用了几次
}
```

上面代码解释:

- 定义一个函数add, 函数名是add, 能接受2个整型参数
- 该函数计算的结果,通过return语句返回"返回值"实现
- 调用时,通过函数名add后加2个参数,返回值可使用变量接收
- 函数名也是标识符
- 返回值也是值
- 一般习惯上函数定义需要在调用之前,也就是说调用时,函数已经被定义过了,请在书写代码时,也尽量这样做,便于阅读代码

## 7.函数调用原理

>  特别注意: 函数定义只是告诉你有一个函数可以用,但这不是函数调用执行其代码,至于函数什么时候被调用,不知道。一定要分清楚定义和调用的区别。

函数调用相当于运行一次函数定义好的代码，函数本来就是为了复用，试想你可以用加法函数，我也可 以用加法函数，你加你的，我加我的，应该互不干扰的使用函数。为了实现这个目标，函数调用的一般 实现，都是把函数压栈（LIFO），每一个函数调用都会在栈中分配专用的栈帧，局部变量、实参、返回 值等数据都保存在这里。

> 一句不准确的口诀: 函数的每一次调用都是独立的,不相干的

函数定义完成以后,它会被编译成cpu可以执行的指令放在内存特定位置

- 每一个进程都有自己使用的内存空间,空间会划分堆、栈
- 每一次调用都会为该次调用在进程用的栈上产生一个栈帧(占用一个字节)

> 注意: go函数不支持形参的缺省值

![函数调用原理](./%E5%87%BD%E6%95%B0.assets/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86.png)

## 8.函数类型

```go
package main
import "fmt" 
func fn1() {}
func fn2(i int) int { return 100 }
func fn3(j int) int { return 200 }

func main() {
    fmt.Printf("%T\n", fn1)
    fmt.Printf("%T\n", fn2)
    fmt.Printf("%T\n", fn3)
}

输出如下
func()
func(int) int
func(int) int
```

## 9.返回值

参考  https://go.dev/ref/spec#Return_statements

- 返回值变量是局部变量

### 9.1 无返回值函数

在Go语言中仅仅一个return并不一定表示无返回值,只能说在一个无返回值的函数中,return表示无返回值函数返回

```go
// 无返回值函数,可以不使用return。或在必要时使用return
func fn1() {
    fmt.Println("无返回值函数")
    return // return 可有可无,如有需求,在必要时候使用return来返回
}
t := fn1() // 错误, 无返回值函数无返回值可用
fmt.Println(fn1()) // 错误,无返回值函数无返回值可打印
```

### 9.2 返回一个值

在函数体中,必须显式执行return

```go
// 返回一个值,没有变量名只有类型,匿名返回值
func fn2() int {
    a := 100
    return a + 1 // return后面只要类型匹配就行
}

fmt.Println(fn2())
t := fn2()
```

```go
// 返回一个值,有变量名和类型,命名返回值
func fn3() (r int) {
    r = 200
    return r - 1 // 类型匹配
}
fmt.Println(fn3())
// 上面的函数还可以写成下面的形式
func fn5() (r int) {
    r = 200
    return // 如果返回的标识符就是返回值列表中的标识符,可以省略
}
fmt.Println(fn3())
```

>  Go语言中返回值不允许赋值给一个常量

### 9.3 返回多值

Go语言时允许函数返回多个值

```go
// 返回多个值
func fn4() (int, bool) {
    a, b := 100, true
    return a, b
}

fmt.Println(fn4())
x, y := fn4() // 需要两个变量接收返回值
```

```go
// 返回多个值
func fn5() (i int, b bool) {
    i,b = 100, true
    return // 如果和返回值列表定义的标识符名称和顺序一样,可省略
}

fmt.Println(fn4())
x,y := fn4() // 需要两个变量接收返回值
```

























