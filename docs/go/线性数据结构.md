# 线性数据结构

## 1.抽象概念

> 线性表: 有序序列,  是一种有序的放元素的容器。【有序表示有编号并且有索引】

## 2.物理实现

### 2.1 内存中怎么表达该序列

> 内存是线性编址的,内部把存储单元小格子编号

## 3.实现方式

### 3.1 顺序表

> 使用连续的内存单元存储该序列的所有元素,内存的顺序就是数据顺序

数组是顺序表的一种表现形式,它在内存中开辟连续的内存空间,变量指向顺序表的第一个元素地址(首地址), 容器占用的内存称为容量(cap), 可以最多容纳多少个元素, 当前容器目标的元素个数称为长度len

```go
// 变量arr 这个标识符指向数组首地址
var arr = [3]int{22, 33, 55} 
```

注意: 顺序Sequence,排序是sort, 这里说的是顺序表

- Create
  - 容器元素个数+1
  - append如同排队,在队尾后增加即可
  - insert插队
    - 队伍最后插入, 就是append
    - 中间插队, 占用当前位置, 把当前位置与其后所有数据后移
    - 队首插队, 所有元素统统后移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大
- Delete
  - 容器元素个数-1
  - pop队尾元素移除,影响最小
  - remove移除
    - 队尾移除, 就是pop
    - 中间移除,后面数据统统前移
    - 队首移除, 所有数据统统前移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大

- Update
  - 元素个数不变
  - 定位问题
  - 更新内容

- Read
  - 定位问题
    - 使用索引, 首地址 + 该类型的占用的字节数 * 偏移数, 所以定位要用索引计算得到的内存地址,不需要遍历, 效率很高
    - 如果使用内容定位, 内容比较, 遍历的方式是挨个元素比较内容,最好的情况是第一个元素就是需要的, 最不好的情况是, 每个元素都比较了一遍,但是没有找到想要的

  - 获取内容: 使用索引直接定位该位置拿走内容
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍【从首地址开始,挨个偏移取内容】


> 顺序表适合仅仅在尾部增删, 还有扩容问题

#### 3.1.1 数组

> 数组: 容器不可变【容器的元素个数不能变】,数组必须给出长度,以后这个数组就不能增删元素【不能扩容】,数组定义的时候必须给出长度
>
> 注意: 数组不可以定义为常量,因为虽然数组的长度不可变但是里面的内容是可变的

- 特点
  - 长度不可变
  - 内容可变
  - 可索引
  - 值类型
  - 顺序表

**定义**

```go
// [3]int是类型, [3]int{}是字面量
var a0 [3]int // 零值初始化3个元素的数组, 这里是数组的定义并未初始化
var a1 = [3]int //零值初始化3个元素的数组
var a2 [3]int = [3]int{1, 3, 5} // 声明且初始化,不推荐
var a3 = [3]int{1, 3, 5} // 声明并初始化
count := 3
// a4 := [count]int{1, 3, 5} 错误的长度类型,必须是常量,换成const
const count1 = 3
a4 := [count1]int{1, 3, 5}
a5 := [...]int{10, 30, 50} // ...让编译器确定当前数组大小
a6 := [5]int{100, 200} // 顺序初始化前面的,其余用零值填充
a7 := [5]int{1: 300, 3: 400} // 指定索引位置初始化,其余用零值填充
// 二维数组 
a8 := [2][3]int{{100}} // 两行三列 [[100 0 0] [0 0 0]] 
// [[10 0 0] [11 12 0] [13 14 15] [16 0 0]]
// 多维数组,只有第一维才能用...推测
// 第一维有4个, 第二维有3个, 可以看做4行3列的表
a9 := [...][3]int{{10}, {11, 12}, {13, 14, 15}, {16}}
```

**长度和容量**

- cap即capacity, 容量, 表示给数组分配的内存空间可以容纳多少个元素
- len即length, 长度, 指的是容器中目前有几个元素

> 由于数组创建时就必须确定的元素个数,且不能改变长度,所以不需要预留多余的内存空间,因此cap和len对数组来说相等

**索引**

Go语言不支持负索引,通过[index]来获取该位置上的值。索引范围就是[0, 长度-1]

**修改**

```go
a5 := [...]int{10, 30, 50}
a5[0] += 100
```

**遍历**

- 索引遍历

```go
a5 := [...]int{10, 30, 50}
for i := 0; i < len(a5); i++ {
    fmt.Println(i, a5[i])
}
```

- for-range遍历

```go
a5 := [...]int{10, 30, 50}
for i,v := range a5 {  // i 索引值 v 数组元素值
    fmt.Println(i, v, a5[i])
}
```

**内存模型**

```go
var a [3]int // 内存开辟空间存放长度为3的数组，零值填充
for i := 0; i < len(a); i++ {
    fmt.Println(i, a[i], &a[i])
}
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
a[0] = 1000
fmt.Printf("%p %p, %v\n", &a, &a[0], a) 

运行结果
0 0 0xc0000101b0
1 0 0xc0000101b8
2 0 0xc0000101c0
0xc0000101b0 0xc0000101b0, [0 0 0]
0xc0000101b0 0xc0000101b0, [1000 0 0] // 因为数组值被替换了,地址没变
```

- 总结:

  - 数组必须在编译时就确定大小,之后不能改变大小
  - 数组首地址就是数组地址
  - 所有元素一个接一个顺序存储在内存中
  - 元素的值可以改变,但是元素地址不变

  上面每个元素间隔8个字节,正好64位,符合int类型定义

```go
a := [3]string{ "abc", "def", "xyz" }
for i := 0; i < len(a); i++ {
    fmt.Println(i, a[i], &a[i])
}
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
a[0] = "oooooo"
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
运行结果
0 abc 0xc000138480
1 def 0xc000138490
2 xyz 0xc0001384a0
0xc000138480 0xc000138480, [abc def xyz]
0xc000138480 0xc000138480, [oooooo def xyz]
```

- 总结
  - 数组首地址就是数组地址
  - 所有元素顺序存储在内存中
  - 元素的值可以改变,但是元素地址不变

> 字符串每个元素间隔16个字节, 因为每一个字符串的地址存储的不是字符串的值,而是标头值, 标头值里包含了8个字节指向字符串的地址

- 数组是值类型,每次赋值都会做副本拷贝【复制】
  - 数组是值类型,值类型完全复制
  - 用它给别的标识符赋值,会复制
  - 函数传入参数时,会复制
  - 函数返回值用数组,会复制
- 通过索引来定位,从0开始
- 内存结构
  - 数组地址就是数组第一个元素的地址
  - 每个元素占用空间看元素类型,int动态类型【看CPU架构32/64 => 4/8】
  - 一个元素占用几个字节和类型有关,第一个元素的存储单元后面一定是第二个元素的存储单元

字符串字面量一旦定义不可改变,不同的字符串长度不一,数组存储string元素,测试发现元素存储空间间隔一样,都是16字节,说明字符串比较复杂，16个字节里面放了一个指针,指向字符串的内存位置。

数组里的元素不能增删,但是数组里的元素给更改【只能给改为同类型的】

```go
// 1.定义一个长度为5的数组类型, 注意: [3]int 与 [5]int这两个不是同一个类型
var a1 = [5]int{5, 3, 11, 21, 2}
```

#### 3.1.2 切片

- 特点
  - 长度可变
  - 内容可变
  - 引用类型
  - 底层基于数组

**定义**

```go
var s1 []int // 长度、容量为0的切片, 零值
var s2 = []int{} // 长度、容量为0的切片,字面量定义
var s3 = []int{1, 3, 5} // 字面量定义, 长度、容量都是3
var s4 = make([]int, 0) // 长度、容量为0的切片, mark([]T, length)
var s5 = make([]int, 3, 5) // 长度为3,容量为5,底层数组的长度为5,元素长度为3,所以显示[0, 0, 0]
```

![image-20250520101234799](./%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20250520101234799.png)

> 切片本质是对底层数组一个连续片段的引用。此片段可以是整个底层数组,也可以是由起始和终止索引标识的一些项子集

```go
// https://github.com/golang/go/blob/master/src/runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

```go
a := []int{1, 3, 5, 7}
fmt.Println("%v %p %p", a, &a, &a[0])
结果如下
[1 3 5 7], 0xc000004078, 0xc000012200
```

> &a是切片结构体的地址, &a[0]是底层数组的地址

**追加**

append: 在切片的尾部追加元素, 长度加1

增加元素后,有可能超过当前容量,导致切片扩容

**长度和容量**

```go
s1 := make([]int, 3, 5)
fmt.Println("s1 %p %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1))
s2 := append(s1, 1, 2) // append会返回一个新的切片
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), 
s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), 
s2)
// 目前没有超过容量，底层共用同一个数组，但是，对底层数组使用的片段不一样
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 1 2]
s3 := append(s1, -1)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
// 目前三个切片底层用同一个数组，只不过长度不一样
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
s4 := append(s3, 3, 4, 5)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4 %p, %p, l=%-2d, c=%-2d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
// 底层数组变了，容量也增加了
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
// s4 0xc000008150, 0xc000012280, l=7 , c=10, [0 0 0 -1 3 4 5]
s5 := append(s4, 6, 7, 8, 9)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4 %p, %p, l=%-2d, c=%-2d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
fmt.Printf("s5 %p, %p, l=%-2d, c=%-2d, %v\n", &s5, &s5[0], len(s5), cap(s5), s5)
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
// s4 0xc000008150, 0xc000012280, l=7 , c=10, [0 0 0 -1 3 4 5]
// s5 0xc0000081c8, 0xc0000260a0, l=11, c=20, [0 0 0 -1 3 4 5 6 7 8 9]
```

**总结**

- append一定返回一个新的切片
- append可以增加若干元素
  - 如果增加元素时,当前长度+新增个数 <= cap则不扩容
    - 原切片使用原来的底层数组,返回的新切片也是用这个底层数组
    - 返回的新切片有新的长度
    - 原切片长度不变
  - 如果增加元素时,当前长度+新增个数 > cap则需要扩容
    - 生成新的底层数组,新生成的切片使用该新数组,将旧元素复制到新数组,其后追加新元素
    - 原切片底层数组,长度、容量不变

**扩容策略**

https://go.dev/src/runtime/slice.go

（老版本）实际上，当扩容后的cap<1024时，扩容翻倍，容量变成之前的2倍；当cap>=1024时，变成 之前的1.25倍。 

（新版本1.18+）阈值变成了256，当扩容后的cap<256时，扩容翻倍，容量变成之前的2倍；当 cap>=256时， newcap += (newcap + 3*threshold) / 4 计算后就是 newcap = newcap + newcap/4 + 192 ，即1.25倍后再加192。

扩容是创建新的底层数组，把原内存数据拷贝到新内存空间，然后在新内存空间上执行元素追加操作。 切片频繁扩容成本非常高，所以尽量早估算出使用的大小，一次性给够，建议使用make。常用 make([]int, 0, 100) 。 

思考一下：如果 s1 := make([]int, 3, 100) ，然后对s1进行append元素，会怎么样？

##### 3.1.2.1 截取子切片

> 切片可以通过指定索引区间获得一个子切片,格式为slice[start:end),规则就是前包后不包

```go
package main
import (
    "fmt"
)
func main() {
    s1 := []int{10, 30, 50, 70, 90} // 容量、长度为5,索引0、1、2、3、4
    for i:=0; i<len(s1);i++ {
        fmt.Printf("%d : addr = %p\n", i, &s1[i])
    }
    fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
    s2 := s1 // 和s1共用底层数组
  	fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
    s3 := s1[:] // 和s1共用底层数组,从头到尾元素都要
	fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
	s4 := s1[1:] // 掐头, 容量、长度都为4,首地址偏移1个元素,共用底层数组
	fmt.Printf("s4 %p, %p, l=%-2d, c=%-2d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
	s5 := s1[1:4] // 掐头去尾, 容量为4, 长度为3, 首地址偏移1个元素, 共用底层数组
	fmt.Printf("s5 %p, %p, l=%-2d, c=%-2d, %v\n", &s5, &s5[0], len(s5), cap(s5), s5)
	s6 := s1[:4] // 去尾, 容量为5, 长度为4, 首地址不变, 共用底层数组
	fmt.Printf("s6 %p, %p, l=%-2d, c=%-2d, %v\n", &s6, &s6[0], len(s6), cap(s6), s6)
	s7 := s1[1:1] // 掐头去尾, 容量为4, 长度为0, 共用底层数组
	fmt.Printf("s7 %p, l=%-2d, c=%-2d, %v\n", &s7, len(s7), cap(s7), s7)
	s8 := append(s7, 11)
	fmt.Printf("s8 %p, %p, l=%-2d, c=%-2d, %v\n", &s8, &s8[0], len(s8), cap(s8), s8)
	s9 := s1[4:4] // 前包后不包 首地址偏移4个元素, 长度为0, 容量为1, 因为最后一个元素没在切片中, 共用底层数组
	fmt.Printf("s9 %p, l=%-2d, c=%-2d, %v\n", &s9, len(s9), cap(s9), s9)
	s10 := s1[5:5] // 首地址偏移5个元素, 长度为0, 容量为0, 共用底层数组
	fmt.Printf("s10 %p, l=%-2d, c=%-2d, %v\n", &s10, len(s10), cap(s10), s10)
	s11 := append(s10, 11)
	fmt.Printf("s11 %p, %p l=%-2d, c=%-2d, %v\n", &s11, &s11[0], len(s11), cap(s11), s11)
}
```

总结:

- 使用slice[start:end]表示切片, 切片长度为end - start, 前包后不包
- start缺省, 表示从索引0开始
- end缺省, 表示取到末尾, 包含最后一个元素,特别注意这个缺省值是len(slice)即切片长度,不是容量
  - a1[5:]相当于a1[5:len(a1)]
- start和end都缺省,表示从头到尾
- start和end同时给出,要求end >= start
  - start、end最大都不可以超过容量值
  - 假设当前容量是8, 长度为5,有以下情况
    - a1[:], 可以,共用底层数组,相当于对标头值的拷贝,也就是指针、长度、容量都一样
    - a1[:8],可以,end最多写成8(因为后不包),a1[:9]不可以。该切片长度、容量都为8,这8个元素都是原序列的,一旦append就扩容
    - a1[8:],不可以,end缺省为当前长度5,等价于a1[8:5]
    - a1[8:8],可以,但这个切片容量和长度都为0了,注意和a1[:8]的区别
    - a1[7:7],可以,但这个切片长度为0,容量为1
    - a1[0:0],可以,这个切片长度为0,容量为8
    - a1[1:5],可以,这个切片长度为4,容量为7,相当于跳过了原序列第一个元素
- 切片刚产生时,和原序列(数组、切片)开始共用同一个底层数组,但是每一个切片都自己独立保存着指针、cap和len
- 一旦一个切片扩容,就和原来共用一个底层数组的序列分道扬镳,从此陌路

#### 3.1.3 字符串

ASCII(American Standard Code for Information Interchange,美国信息交换标准代码)是基于拉丁字母的一套单字节编码系统

![image-20250602164105756](.\线性数据结构.assets\image-20250602164105756.png)

熟记下面表格中特殊字符
![image-20250602164153648](.\线性数据结构.assets\image-20250602164153648.png)

> 注意: 这里的1指的是字符1,不是数字1
>
> UTF-8、GBK都兼容了ASCII

```go
// 'A' > 'a' 因为a的ASCII对应97,A对应65,'a'大
// "AA" > "Aa" 先比较第一个字符, 如果相同再比较第二个字符  
```

##### 3.1.3.1 字符

本质上来说,计算机中一切都是字节的,字符串也是多个字节组合而成,就是多个字节形成的有序序列。但是对于多字节编码的中文来说,用一个字节描述不了,需要多个字节表示一个字符,Go提供了rune类型。

- byte: 兼容ASCII码的字符,是byte类型,即uint8别名,占用1个字节
- rune: 汉字等字符,unicode编码,是rune类型,即int32别名,占用4个字节
- 一个字符字面量使用单引号引用起来

```go
s1 := "abc"
s2 := "测试"
fmt.Println(len(s1), len(s2)) // 3, 6字节
// 强制类型转换 string => []byte; string => []rune
// 注意[]byte表示字节序列; []rune表示rune序列
fmt.Println([]byte(s1))
fmt.Println([]rune(s1))
fmt.Println([]byte(s2)) // utf-8 bytes,长度为6即6个字节
fmt.Println([]rune(s2)) // unicode切片, 长度为2,每个元素4个字节
fmt.Printf("%x, %x", 27979, 35797)
fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~")
// []byte => string
fmt.Println(string([]byte{49, 65, 97}))
// []rune => string
fmt.Println(string([]rune{27979, 35797}))
// rune使用unicode，但是字符串内部使用utf-8
fmt.Println(s2[0], s2[1], s2[2]) // 索引取到了什么？
fmt.Println(string([]byte{230, 181, 139})) // 打印什么？
```

- string(一个整数),强制类型转换一个整数,相当于把整数当unicode码,去查一个字符,最后返回字符串
- string(整数序列),强制类型转换一个整数序列,也是转成字符串

##### 3.1.3.2 字符串

- 字面常量,只读,不可变
- 线性数据结构,可以索引
- 值类型
- utf-8编码

###### 长度

使用内建函数len,返回字符串占用的字节数,时间复杂度为O(1),字符串是字面常量,定义时已经知道长度,记录下来即可

###### 索引

- 不支持负索引,索引范围[0, len(s)-1]
- 即使有中文,索引指的是按照字节的偏移量
- 时间复杂度O(1),使用索引计算该字符相对开头的偏移量即可
- 对于顺序表来说,使用索引效率是最高的
- s[i]获取索引i处的utf-8编码的一个字节

###### 遍历

C风格使用索引遍历,相当于字节遍历

```go
s := "magedu马哥教育"
for i:=0;i<len(s);i++ {
    fmt.Printf("%d, %T, %[2]d %[2]c\n", i, s[i])
}
```

for-range遍历,安全地遍历字符

```go
s := "magedu马哥教育"
for i,v:=range s {
    fmt.Printf("%d, %T: %[2]d %[2]c; %T: %[3]d %[3]c\n", i, s[i], v) // 注意i不连续。v是汉字的unicode
}
```

###### strings库

- 拼接
  - Join: 使用间隔符拼接字符串切片
  - Builder: 多次拼接,推荐
  - fmt.Sprintf: 方便快捷

```go
s0 := "www.magedu.edu"
s1 := "马哥教育"
fmt.Printf("s0&s1 %s %p; %s %p\n", s0, &s0, s1, &s1)
s2 := s0 + "-" + s1
fmt.Printf("s2 %s %p\n", s2, &s2)
s3 := strings.Join([]string{s0, s1}, "-")
fmt.Printf("s3 %s %p\n", s3, &s3)
s4 := fmt.Sprintf("%s-%s", s0, s1)
fmt.Printf("s4 %s %p\n", s4, &s4)
var b strings.Builder
b.WriteString(s0)
b.WriteByte('-')
b.WriteString(s1)
s5 := b.String()
fmt.Printf("s5 %s %p\n", s5, &s5)
```

> 简单拼接字符串常用+、fmt.Sprintf。
>
> 如果手里正好有字符串的序列,可以考虑Join。
>
> 如果反复多次拼接,strings.Builder是推荐的方式
>
> bytes.Buffer用法同strings.Builder

- 查询
  - Index: 从左至右搜索,返回子串第一次出现的字节索引位置。未找到返回-1。子串为空,也返回0
  - LastIndex: 从右至左搜索,返回子串第一次出现的字节索引位置。未找到,返回-1
  - IndexByte、IndexRune与Index类似;LastIndexByte与LastIndex类似
  - IndexAny:从左至右搜索,找到给定的字符集字符串中任意一个字符就返回索引位置。未找到返回-1
  - Contains方法本质上就是**Index**方法,只不过返回bool值,方便使用bool值时使用
  - LastIndexAny与IndexAny搜索方向相反
  - Count:从左到右搜索子串,返回子串出现的次数

> 时间复杂度是O(n)，效率不高，该用则用，但要少用。

```go
 s := "www.magedu.com马哥教育"
 fmt.Println('马', "马"[0])
 fmt.Println(
 strings.Index(s, "马"),
 strings.IndexAny(s, "马m"),
 strings.IndexByte(s, 233),
 strings.IndexRune(s, 39532),
 strings.Contains(s, "马"),
 strings.Count(s, "m"),
 )
```

- 大小写
  - ToLower: 转换为小写
  - ToUpper: 转换位大写
- 前后缀
  - HasPrefix: 是否以子串开头
  - HasSuffix: 是否以子串结尾

###  3.2 链接表

> 每一个元素存储在内存中,但是元素并不是连续的存储在内存中,散落在内存的不同位置,前一个元素指向下一个元素【双向链表中,下一个元素也会指向上一个元素】(链接)【简称链表】可以理解为手拉手

链表是个容器,可以放元素,定义一个变量指向链表第一个元素地址即可(首地址), 在链表中会定义一个首部(head)和尾部(tail)的两个地址

cap是指当前放了多少个元素,和len一致的,不需要提前开辟内存空间

链表可以分为单向和双向

- 单向	前一个元素指向下一个元素
- 双向    前一个元素指向下一个元素,下一个元素指向上一个元素

列表List往往是链表的表现形式【python除外】

- Create
  - 容器个数+1
  - 尾部插入,原来的尾部指向新尾部,容器需要改tail,没有数据挪动,很快
  - 中间插入,断开原来的链接,分别和新元素拉手,没有数据挪动,代价不大
  - 首部插入,原来的首部和新首部互指,容器需要改head,没有数据挪动, 代价不大
- Delete
  - 容器个数-1
  - 尾部删除, 容器重新定位tail,当前尾部的前一个成为新的tail,删除旧tail的元素
  - 中间删除,遍历定位,当前元素删除,前驱、后继拉手即可
  - 首部删除,容器重新定位head,当前head的下一个元素成为新的head,删除旧的head元素
- Update
  - 元素个数len不变
  - 定位问题
  - 更新内容
- Read
  - 定位问题
    - 使用索引, 由于元素散落在内存中,不能使用顺序表公式来定位,找到head依次遍历索引。按照遍历元素的方式来找的,但是取的每一个节点中保存的下一个地址,使用该地址定位下一个元素和顺序表比起来略慢, 但是由于使用地址效率还可以
    - 使用内容查找定位,需要遍历查找,效率低下
  - 获取内容: 
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍

> 链接表适合规模大的对数据进行增删,不需要扩容,新增时找到一个位置放当前元素即可,修改指向(链接地址)



**注意: 二分法查找有一个前提,就是已经为元素排过序了,而排序非常耗时,非必要不要做排序**

## 4.常见线性数据结构

- 数组array
  - 数组
  - 切片
- 链表Linked List
  - list
- 栈Stack
  - 后进先出LIFO(可以理解为子弹夹),不可以首部、中间操作
  - 只能尾部追加,尾部移除
  - 物理实现
    - 顺序表【顺序表扩容,需要连续的大空间】
    - 链接表【更合适,多数使用链表实现】
    - stack底层是使用双端队列实现
- 队列Queue
  - 消息中间件(消息队列)
  - 一般队列不允许中间操作,不提供中间操作的方法
  - 先进先出FIFO,不可以中间和尾部移除,首部移除增加只能在尾部,中间和首部不可以插入
    - 物理实现: 链接表。因为头部移除,对于顺序表代价过高,其后元素往前挪动
    - 使用双端队列实现
  - 双端队列 deque
    - 两头操作,操作只能在两头,尾部追加或移除，首部插入或移除,中间不可以操作
    - 物理实现 链表实现
  - 优先队列,数据结构是堆(小顶堆实现),不是线性数据结构实现































