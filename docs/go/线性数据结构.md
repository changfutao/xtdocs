# 线性数据结构

## 1.抽象概念

> 线性表: 有序序列,  是一种有序的放元素的容器。【有序表示有编号并且有索引】

## 2.物理实现

### 2.1 内存中怎么表达该序列

> 内存是线性编址的,内部把存储单元小格子编号

## 3.实现方式

### 3.1 顺序表

> 使用连续的内存单元存储该序列的所有元素,内存的顺序就是数据顺序

数组是顺序表的一种表现形式,它在内存中开辟连续的内存空间,变量指向顺序表的第一个元素地址(首地址), 容器占用的内存称为容量(cap), 可以最多容纳多少个元素, 当前容器目标的元素个数称为长度len

```go
// 变量arr 这个标识符指向数组首地址
var arr = [3]int{22, 33, 55} 
```

注意: 顺序Sequence,排序是sort, 这里说的是顺序表

- Create
  - 容器元素个数+1
  - append如同排队,在队尾后增加即可
  - insert插队
    - 队伍最后插入, 就是append
    - 中间插队, 占用当前位置, 把当前位置与其后所有数据后移
    - 队首插队, 所有元素统统后移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大
- Delete
  - 容器元素个数-1
  - pop队尾元素移除,影响最小
  - remove移除
    - 队尾移除, 就是pop
    - 中间移除,后面数据统统前移
    - 队首移除, 所有数据统统前移
    - 挪动数据是要消耗时间的,挪动的元素越多(规模越大),代价越大

- Update
  - 元素个数不变
  - 定位问题
  - 更新内容

- Read
  - 定位问题
    - 使用索引, 首地址 + 该类型的占用的字节数 * 偏移数, 所以定位要用索引计算得到的内存地址,不需要遍历, 效率很高
    - 如果使用内容定位, 内容比较, 遍历的方式是挨个元素比较内容,最好的情况是第一个元素就是需要的, 最不好的情况是, 每个元素都比较了一遍,但是没有找到想要的

  - 获取内容: 使用索引直接定位该位置拿走内容
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍【从首地址开始,挨个偏移取内容】


> 顺序表适合仅仅在尾部增删, 还有扩容问题

#### 3.1.1 数组

> 数组: 容器不可变【容器的元素个数不能变】,数组必须给出长度,以后这个数组就不能增删元素【不能扩容】,数组定义的时候必须给出长度
>
> 注意: 数组不可以定义为常量,因为虽然数组的长度不可变但是里面的内容是可变的

- 特点
  - 长度不可变
  - 内容可变
  - 可索引
  - 值类型
  - 顺序表

**定义**

```go
// [3]int是类型, [3]int{}是字面量
var a0 [3]int // 零值初始化3个元素的数组, 这里是数组的定义并未初始化
var a1 = [3]int //零值初始化3个元素的数组
var a2 [3]int = [3]int{1, 3, 5} // 声明且初始化,不推荐
var a3 = [3]int{1, 3, 5} // 声明并初始化
count := 3
// a4 := [count]int{1, 3, 5} 错误的长度类型,必须是常量,换成const
const count1 = 3
a4 := [count1]int{1, 3, 5}
a5 := [...]int{10, 30, 50} // ...让编译器确定当前数组大小
a6 := [5]int{100, 200} // 顺序初始化前面的,其余用零值填充
a7 := [5]int{1: 300, 3: 400} // 指定索引位置初始化,其余用零值填充
// 二维数组 
a8 := [2][3]int{{100}} // 两行三列 [[100 0 0] [0 0 0]] 
// [[10 0 0] [11 12 0] [13 14 15] [16 0 0]]
// 多维数组,只有第一维才能用...推测
// 第一维有4个, 第二维有3个, 可以看做4行3列的表
a9 := [...][3]int{{10}, {11, 12}, {13, 14, 15}, {16}}
```

**长度和容量**

- cap即capacity, 容量, 表示给数组分配的内存空间可以容纳多少个元素
- len即length, 长度, 指的是容器中目前有几个元素

> 由于数组创建时就必须确定的元素个数,且不能改变长度,所以不需要预留多余的内存空间,因此cap和len对数组来说相等

**索引**

Go语言不支持负索引,通过[index]来获取该位置上的值。索引范围就是[0, 长度-1]

**修改**

```go
a5 := [...]int{10, 30, 50}
a5[0] += 100
```

**遍历**

- 索引遍历

```go
a5 := [...]int{10, 30, 50}
for i := 0; i < len(a5); i++ {
    fmt.Println(i, a5[i])
}
```

- for-range遍历

```go
a5 := [...]int{10, 30, 50}
for i,v := range a5 {  // i 索引值 v 数组元素值
    fmt.Println(i, v, a5[i])
}
```

**内存模型**

```go
var a [3]int // 内存开辟空间存放长度为3的数组，零值填充
for i := 0; i < len(a); i++ {
    fmt.Println(i, a[i], &a[i])
}
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
a[0] = 1000
fmt.Printf("%p %p, %v\n", &a, &a[0], a) 

运行结果
0 0 0xc0000101b0
1 0 0xc0000101b8
2 0 0xc0000101c0
0xc0000101b0 0xc0000101b0, [0 0 0]
0xc0000101b0 0xc0000101b0, [1000 0 0] // 因为数组值被替换了,地址没变
```

- 总结:

  - 数组必须在编译时就确定大小,之后不能改变大小
  - 数组首地址就是数组地址
  - 所有元素一个接一个顺序存储在内存中
  - 元素的值可以改变,但是元素地址不变

  上面每个元素间隔8个字节,正好64位,符合int类型定义

```go
a := [3]string{ "abc", "def", "xyz" }
for i := 0; i < len(a); i++ {
    fmt.Println(i, a[i], &a[i])
}
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
a[0] = "oooooo"
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
运行结果
0 abc 0xc000138480
1 def 0xc000138490
2 xyz 0xc0001384a0
0xc000138480 0xc000138480, [abc def xyz]
0xc000138480 0xc000138480, [oooooo def xyz]
```

- 总结
  - 数组首地址就是数组地址
  - 所有元素顺序存储在内存中
  - 元素的值可以改变,但是元素地址不变

> 字符串每个元素间隔16个字节, 因为每一个字符串的地址存储的不是字符串的值,而是标头值, 标头值里包含了8个字节指向字符串的地址

- 数组是值类型,每次赋值都会做副本拷贝【复制】
  - 数组是值类型,值类型完全复制
  - 用它给别的标识符赋值,会复制
  - 函数传入参数时,会复制
  - 函数返回值用数组,会复制
- 通过索引来定位,从0开始
- 内存结构
  - 数组地址就是数组第一个元素的地址
  - 每个元素占用空间看元素类型,int动态类型【看CPU架构32/64 => 4/8】
  - 一个元素占用几个字节和类型有关,第一个元素的存储单元后面一定是第二个元素的存储单元

字符串字面量一旦定义不可改变,不同的字符串长度不一,数组存储string元素,测试发现元素存储空间间隔一样,都是16字节,说明字符串比较复杂，16个字节里面放了一个指针,指向字符串的内存位置。

数组里的元素不能增删,但是数组里的元素给更改【只能给改为同类型的】

```go
// 1.定义一个长度为5的数组类型, 注意: [3]int 与 [5]int这两个不是同一个类型
var a1 = [5]int{5, 3, 11, 21, 2}
```

### 3.1.2 切片

- 特点
  - 长度可变
  - 内容可变
  - 引用类型
  - 底层基于数组

**定义**

```go
var s1 []int // 长度、容量为0的切片, 零值
var s2 = []int{} // 长度、容量为0的切片,字面量定义
var s3 = []int{1, 3, 5} // 字面量定义, 长度、容量都是3
var s4 = make([]int, 0) // 长度、容量为0的切片, mark([]T, length)
var s5 = make([]int, 3, 5) // 长度为3,容量为5,底层数组的长度为5,元素长度为3,所以显示[0, 0, 0]
```

![image-20250520101234799](./%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20250520101234799.png)

> 切片本质是对底层数组一个连续片段的引用。此片段可以是整个底层数组,也可以是由起始和终止索引标识的一些项子集

```go
// https://github.com/golang/go/blob/master/src/runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

```go
a := []int{1, 3, 5, 7}
fmt.Println("%v %p %p", a, &a, &a[0])
结果如下
[1 3 5 7], 0xc000004078, 0xc000012200
```

> &a是切片结构体的地址, &a[0]是底层数组的地址

**追加**

append: 在切片的尾部追加元素, 长度加1

增加元素后,有可能超过当前容量,导致切片扩容

**长度和容量**

```go
s1 := make([]int, 3, 5)
fmt.Println("s1 %p %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1))
s2 := append(s1, 1, 2) // append会返回一个新的切片
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), 
s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), 
s2)
// 目前没有超过容量，底层共用同一个数组，但是，对底层数组使用的片段不一样
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 1 2]
s3 := append(s1, -1)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
// 目前三个切片底层用同一个数组，只不过长度不一样
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
s4 := append(s3, 3, 4, 5)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4 %p, %p, l=%-2d, c=%-2d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
// 底层数组变了，容量也增加了
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
// s4 0xc000008150, 0xc000012280, l=7 , c=10, [0 0 0 -1 3 4 5]
s5 := append(s4, 6, 7, 8, 9)
fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3 %p, %p, l=%-2d, c=%-2d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4 %p, %p, l=%-2d, c=%-2d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
fmt.Printf("s5 %p, %p, l=%-2d, c=%-2d, %v\n", &s5, &s5[0], len(s5), cap(s5), s5)
// s1 0xc000008078, 0xc00000e390, l=3 , c=5 , [0 0 0]
// s2 0xc0000080a8, 0xc00000e390, l=5 , c=5 , [0 0 0 -1 2]
// s3 0xc0000080f0, 0xc00000e390, l=4 , c=5 , [0 0 0 -1]
// s4 0xc000008150, 0xc000012280, l=7 , c=10, [0 0 0 -1 3 4 5]
// s5 0xc0000081c8, 0xc0000260a0, l=11, c=20, [0 0 0 -1 3 4 5 6 7 8 9]
```

**总结**

- append一定返回一个新的切片
- append可以增加若干元素
  - 如果增加元素时,当前长度+新增个数 <= cap则不扩容
    - 原切片使用原来的底层数组,返回的新切片也是用这个底层数组
    - 返回的新切片有新的长度
    - 原切片长度不变
  - 如果增加元素时,当前长度+新增个数 > cap则需要扩容
    - 生成新的底层数组,新生成的切片使用该新数组,将旧元素复制到新数组,其后追加新元素
    - 原切片底层数组,长度、容量不变

**扩容策略**

https://go.dev/src/runtime/slice.go

（老版本）实际上，当扩容后的cap<1024时，扩容翻倍，容量变成之前的2倍；当cap>=1024时，变成 之前的1.25倍。 

（新版本1.18+）阈值变成了256，当扩容后的cap<256时，扩容翻倍，容量变成之前的2倍；当 cap>=256时， newcap += (newcap + 3*threshold) / 4 计算后就是 newcap = newcap + newcap/4 + 192 ，即1.25倍后再加192。

扩容是创建新的底层数组，把原内存数据拷贝到新内存空间，然后在新内存空间上执行元素追加操作。 切片频繁扩容成本非常高，所以尽量早估算出使用的大小，一次性给够，建议使用make。常用 make([]int, 0, 100) 。 

思考一下：如果 s1 := make([]int, 3, 100) ，然后对s1进行append元素，会怎么样？

#### 3.1.2.1 截取子切片

> 切片可以通过指定索引区间获得一个子切片,格式为slice[start:end),规则就是前包后不包

```go
package main
import (
    "fmt"
)
func main() {
    s1 := []int{10, 30, 50, 70, 90} // 容量、长度为5,索引0、1、2、3、4
    for i:=0; i<len(s1);i++ {
        fmt.Printf("%d : addr = %p\n", i, &s1[i])
    }
    fmt.Printf("s1 %p, %p, l=%-2d, c=%-2d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
    s2 := s1 // 和s1共用底层数组
  	fmt.Printf("s2 %p, %p, l=%-2d, c=%-2d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
}
```



### 3.2 链接表

> 每一个元素存储在内存中,但是元素并不是连续的存储在内存中,散落在内存的不同位置,前一个元素指向下一个元素【双向链表中,下一个元素也会指向上一个元素】(链接)【简称链表】可以理解为手拉手

链表是个容器,可以放元素,定义一个变量指向链表第一个元素地址即可(首地址), 在链表中会定义一个首部(head)和尾部(tail)的两个地址

cap是指当前放了多少个元素,和len一致的,不需要提前开辟内存空间

链表可以分为单向和双向

- 单向	前一个元素指向下一个元素
- 双向    前一个元素指向下一个元素,下一个元素指向上一个元素

列表List往往是链表的表现形式【python除外】

- Create
  - 容器个数+1
  - 尾部插入,原来的尾部指向新尾部,容器需要改tail,没有数据挪动,很快
  - 中间插入,断开原来的链接,分别和新元素拉手,没有数据挪动,代价不大
  - 首部插入,原来的首部和新首部互指,容器需要改head,没有数据挪动, 代价不大
- Delete
  - 容器个数-1
  - 尾部删除, 容器重新定位tail,当前尾部的前一个成为新的tail,删除旧tail的元素
  - 中间删除,遍历定位,当前元素删除,前驱、后继拉手即可
  - 首部删除,容器重新定位head,当前head的下一个元素成为新的head,删除旧的head元素
- Update
  - 元素个数len不变
  - 定位问题
  - 更新内容
- Read
  - 定位问题
    - 使用索引, 由于元素散落在内存中,不能使用顺序表公式来定位,找到head依次遍历索引。按照遍历元素的方式来找的,但是取的每一个节点中保存的下一个地址,使用该地址定位下一个元素和顺序表比起来略慢, 但是由于使用地址效率还可以
    - 使用内容查找定位,需要遍历查找,效率低下
  - 获取内容: 
  - 遍历: 容器中的元素,不管有没有顺序,我们都要不重复的将所有元素挨个摸一遍

> 链接表适合规模大的对数据进行增删,不需要扩容,新增时找到一个位置放当前元素即可,修改指向(链接地址)



**注意: 二分法查找有一个前提,就是已经为元素排过序了,而排序非常耗时,非必要不要做排序**







