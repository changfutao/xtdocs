# 基础语法

## 1.注释

- // 单行注释
- /* 多行注释 */

```powershell
// TODO: 将来完成 【可以在vscode里安装一个Todo Tree插件管理代码】
// NOTE: 请注意
// Deprecated: 告知已经过期, 建议不要使用。未来某个版本可能移除
```

## 2.分割

> 在Go语言中把行分隔符作为一条语句的结尾。也就是说,一般情况下,一行结束。

## 3.命名规范

- 标识符采用CamelCase驼峰命名法
  - 如果只在包内可用,就采用小驼峰命名
  - 如果要在包外可见,就采用大驼峰命名
- 简单循环变量可以使用i、j、k、v等
- 条件变量、循环变量可以是单个字母或单个单词,Go倾向于使用单个字母。Go建议使用更短小。
- 常量使用驼峰命名
- 函数/方法的参数、返回值应是单个单词或单个字母
- 函数可以是多个单词命名,包名应该和导入路径的最后一段路径保持一致
- 接口优先采用单个单词命名,一般加er后缀。Go语言推荐尽量定义小接口,接口也可以组合

## 4.关键字

[文档地址]: https://golang.google.cn/ref/spec

```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

## 5.预定义标识符

[文档地址]: https://golang.google.cn/ref/spec#Predeclared_identifiers

```
Types:
	any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr
	
Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len make new panic print println real recover
```

## 6.标识符

- 一个名字,本质上是个字符串,用来指代一个值
- 只能是大小写字母、数字、下划线,也可以是Unicode字符
- 不能以数字开头
- 不能是Go语言的关键字
- 尽量不要使用"预定义标识符",否则后果难料
- 大小写敏感

### 6.1标识符建议： 

- 不要使用中文 
- 非必要不要使用拼音 
- 尽量遵守上面的命名规范，或形成一套行之有效的命名规则

## 7.字面常量

它是值,不是标识符,但本身就是常量,不能被修改

Go语言中,boolean、rune、integer、float、complex、string都是字面常量。其中rune、integer、float、complex常量被称为数值常量

```
"abc"
'a'
true
1
3.14
```

```go
// 在go中整数字面量默认是int
var a = 13 // int类型
```



> 无类型常量的缺省类型为bool、rune、int、float64、complex128或字符串

## 8.常量

> 常量: 使用const定义一个标识符,它对应的值不允许修改

对常量并不要求全大写加下划线的命名规则

> 注意: 常量必须定义时赋值,否则报错

```go
const a int = 100 // 指定类型定义常量并赋值
// 定义多个常量
const (
  b = "abc"  // 定义常量,等式左边并未给出类型,将进行类型推导
  c = 12.3
  d = 'T'
)
const e // 错误, const定义常量,必须在定义时赋值,并且之后不能改变
const c = [2]int{1, 2} // 错误, 数组的容器内容会变化,不能在编译期间明确的确定下来, 所以不能使用const，应该使用var
```

> 注意：Go语言的常量定义，必须是能在编译器就要完全确定其值，所以，值只能使用字面常量。

### 8.1 iota

```go
// 单独写iota都是从0开始
const a = iota // 0
const b = iota // 0
```

```go
// 批量写iota从0开始, iota是行索引,在第一行不管有几个iota都是0
const (
  SUN = iota // 0 
  MON = iota // 1
  TUE = iota // 2
)
// 简化
const (
  SUN = iota
  MON
  TUE
)
```

```go
// 批量写iota从0开始,即使第一行没有写iota,iota也从第一行开始,从0开始增加
const (
  a = iota // 0
  b // 1 下一行没有赋值的话,那么会继承自上一行,相当于b = iota 等于1
  c // 2
  _ // 3
  d = 10 // 10
  e // 10
  g = iota // 6, iota从第一行为0开始算, 每一行加1
  h // 7
)
```

```go
const (
    a = (iota + 1) * (iota + 1) // 1 iota批量定义时是行索引,不管几个iota都是0
    b // 4
    c // 9
    d // 16
)
```

## 9.变量赋值

变量: 赋值后,可以改变值的标识符。

```go
var n1 // 错误, 如果不赋值,编译器无法推测类型
var n2 int // 正确, 只声明,编译器会自动给n2赋初始值
var a = 100 // 类型推导为int
var b:float64 = 3.25 // 直接指定类型
b = 5.1 // 错误, b多次声明
// 批量变量定义用 var ()
var (
  c = true // 类型推导
  d = 123
  w int = 333
)
// 或者
var e, f int // 如果要写在一行,必须同类型,只需要在最后指定类型就行
var g, h int = 100, 120 // 定义同一行并且赋值【必须两个都赋值】
var q = nil // 错误 非法,nil不允许这样用
```

```go
// 短格式 注意: 短格式不能定义在全局中
// _ 空白标识符,或称为匿名变量
func main() {
    a := 100
    b, c := 200, "xyz"
    // 交换
    d := 300
    e := 500
    e, d = d, e // e: 300 d: 500 可以理解为等号右侧先执行, 那么d指向了300 e指向了500【这里可以理解为照相的快照定格了(拿到了d和e的内存地址, 拷贝了一份)】, 再执行左侧, e指向了300 d指向了500
    // _ 空白标识符, 只能用于左边, 其他地方不可以用【只是一个占位符】
    f, _ , h := 100, 200, 300
    u, _, o = func()(int, string, bool) { return 300, "ok", true }() // 函数执行后将返回的三个值赋给u, _, o
}
```

### 9.1 下划线

> _下划线是空白标识符

- 下划线和其他标识符使用方式一样,但它不会分配内存,不占名词空间
- 为匿名变量赋值,其值会被抛弃,因此后续代码中不能使用匿名变量的值,也不能使用匿名变量为其他变量赋值

### 9.2 短格式

- 使用:=定义变量并立即初始化
- 只能用再函数中,不能用来定义全局变量
- 不能提供数据类型,由编译器来推导

### 9.3 零值

变量已经被声明,但是未被显式初始化,这是变量将会被设置为零值。

- int: 0
- float: 0.0
- bool: false
- string: ""
- 指针: nil

### 9.4 标识符本质

每一个标识符对应一个具有数据结构的值,但是这个值不方便直接访问,程序员就可以通过其对应的标识符来访问数据,标识符就是一个指代。

- 标识符源代码时候,用来指代某个值的。编译后还有变量、常量标识符码?
  - 答: 没有了,因为数据在内存中,内存访问靠什么? **地址**,标识符编译后就没有了换成了地址
- 编译会生成二进制可执行文件并执行,在内存中开启进程,进程内有你定义的数据

## 10.变量可见性

### 10.1 包级标识符

在Go语言中,在.go文件中的顶层代码中,定义的标识符称为包级标识符。如果首字母大写,可在包外包内可见。如果首字母小写,则包内可见。

> 同一个目录就是同一个包,同一个目录里面只能有一个包

```go
// 例如: 在ch1文件夹下有main.go 和 a.go, 那么它们俩文件内部只能定义同一个package 包名
package main
import "fmt" // 导入包或第三方包
var d = "abc" // 顶层代码, 包内的全局变量， 包内可见
var E = "xyz" // 包内全局可见, 包外也可以; 可以导出,可以外漏到包外
func main() { // main函数叫做入口函数,go约定main函数必须在main包中定义
    // Println 包外可见
    fmt.Println(d)
}
```

**使用建议**

- 顶层代码中定义包级标识符
  - 首字母大写作为包导出标识符,首字母小写作为包内可见标识符
  - const定义包级常量,必须在声明时初始化
  - var定义包级变量
    - 可以指定类型,也可以使用无类型常量定义
    - 延迟赋值必须指定类型,不然无法确定零值
- 有相关关系的,可以批量定义在一起
- 一般声明时,还是考虑"就近原则",尽量靠近第一次使用的地方声明
- 不能使用短格式定义

### 10.2 局部标识符

定义在函数中,包括main函数,这些标识符就是局部标识符

使用建议

- 在函数中定义的标识符
- const定义局部常量
- var定义局部变量
  - 可以指定类型,也可以使用无类型常量定义
  - 延迟赋值必须指定类型,不然无法确定零值
- 有相关关系的,可以批量定义在一起
- 在函数内,直接赋值的变量多采用短格式定义

## 11.类型

### 11.1 布尔型

类型bool,定义了2个预定义常量,分别是true、false

### 11.2 数值型

[数值型]: https://golang.google.cn/ref/spec#Numeric_types

复数: complex64、complex128

#### 11.2.1 整数

- 长度不同【有符号】: int8、int16(C语言 short)、int32、int64(C语言 long) 
  - 最高位是符号位
  - rune类型本质上就是int32;  type rune = int32 类型 别名 type定义时使用了 =, 
- 长度不同无符号【有符号】: uint8、uint16、uint32、uint64
  - u即unsigned,最高位不是符号位
  - byte类型,它是uint8的别名
- 自动匹配平台: int、uint
  - int类型它至少占用32位,但一定注意它不等同于int32,不是int32的别名。要看CPU,32位就是4字节,64位就是8字节。但是,也不是说int是8字节64位,就等同于int64,它们依然是不同类型

**扩展知识**

计算机内部是使用二进制的，也就是只有0和1，那如何表达出正负数的区别呢？（为了让初学者便于理 解，不引入补码表示法） 为了方便以单字节为例，1个字节是8位，那么可以表示256种状态。 如何表示十进制2呢？它是00000010。那十进制-2，如何表示？ 那就把最高位单独解释，最高位定为符号位，0表示正号，1表示负号。-2用二进制表示为10000010

```go
// 十进制 2
// 第一位表示符号 0为正 1为负
0	000 0010
// 十进制 -2  【补码】符号位不动,其余位按位取反,最后加1
1   000 0010
// 因为-2要补码, 下面是结果
1   111 1101  + 1 
// =>
1   111 1110
// 上面为啥要补码, 因为为了把减法当作加法做
```

```go
// 扩展知识
package main
import "fmt"
func main() {
    var a = 100
    var b = 200
    // Printf 向控制台打印, f是format %T是占位符,%T表示type,取值的类型
    fmt.Printf("%T %T %T\n", a, b, a + b)
    // %d 占位符 digital 数值形式,往往用于整数
    fmt.Printfln("%d", a) 
    // %s 占位符 string类型的值; %q 占位符 带字符串类型引号的%s  q表示 quote引号的意思
    fmt.Printfln("%s %q", string(50), string(50)) // 2 "2" string(整数值看作是ASCII或UniCode码)
    var m int64 = 50
    // [2] => string(m), [1] => rune(m)
    fmt.Printfln("%[2]T %[1]d", rune(m), string(m)) // 值从1开始编 rune(m)表示索引1, string(m)表示索引2
    fmt.Printfln("%d, %[1]d, %d", 100, 200, 300) // 输出 100 100 200 因为第三个%d没有指定索引,所以将第二个索引+1
    var a1 = '测' // rune 类型 本质是int32
    // %c 占位符 character 字符输出
    fmt.Printf("%T %d %c", a1) // 内存中一个数据,看你赋予它什么类型,就可以看到不同的东西 
    a1 = 'c' // 重新赋值,类型不变
    a = 0x63 // 重新赋值, 0x63是整数标识符  0x63是字面常量,默认是int类型, 隐式类型转换
    // 相当于 a = (int32)0x63 
    a = '\x63' // \x是指16进制字符表示法
    
    var aa = '测' // rune类型 unicode编码 
    var bb = "测" // string类型 utf-8类型,内存中使用utf-8编码保存字符串的字符
}
```

```go
type myint int32 // 特别注意这里没有等号=, 这不是别名,它是新类型,新和旧类型不是同一个类型【本质上是一样,但是定义的数据不能直接通用】
type myint64 = int64 // 类型别名
```

> 可以认为go中没有字符类型,本质上是int32的别名,习惯上称rune为字符类型
>
> 在go中隐式类型转换,只限于untyped constant 无类型字面量

#### 11.2.2 浮点数

```go
package main
import "fmt"
func main() {
	var a = 1000.2486
    fmt.Printf("%f\n", a) // %f占位符 浮点数输出
    fmt.Printf("%.2f\n", a) // 保留两位小数输出
    fmt.Printf("%10f\n", a) // 打印宽度为10【a的长度为9, 前面会空出一个空格来】, 默认右对齐
    fmt.Printf("%10.2f\n", a) // 打印宽度为10,保留2位小数
    fmt.Printf("%-10.1f】\n", a) // 打印宽度为10,保留1位小数,左对齐
}
```





































