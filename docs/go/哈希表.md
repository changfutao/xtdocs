# 映射

### 1.映射

映射Map, 也有语言称为字典

- 长度可变
- 存储的元素是key-value对(键值对), value可变
- key无序不重复
- 不可索引,需要通过key来访问
- 不支持零值可用,也就是说,必须要用make或字面常量构造
- 引用类型
- 哈希表

## 2.哈希表

### 1.基础概念

> map是go中哈希表的实现

存储kv对,一个kv对称为一个元素,键值对entry、item

- len表示元素的个数,即kv对的个数
- 没法获取cap
- key不能重复,无序
  - key按照某种先后顺序加入到map中,但是从哈希表中看不出顺序来
  - key是关键的,唯一
  - key相同,会去重
  - 无序
    - 举例x、y如果用序列(线性表)表达,我认为x是y的前驱,y是x的后继
    - 在hash table中,x、y如果认为是key,不认为有前后依存关系,认为是不一样的独立的不同的key,当然在物理存储上,也是在空间中相对位置不确定
- 哈希不是线性表,是无序的,不能编号,也不能索引
- 引用类型
  - 有一个标头值
  - 有一个指针指向底层的hash表
- 不支持零值可用
- 高效、依赖与key,用空间换时间

### 2.哈希原理

#### 2.1 概念

hash哈希是一种算法

- y=hash(x)给定一个x一定得到固定的y
- x是输入,x取值范围称为输入空间,x是任意值,x是任意长度(go中字节序列)
- y是输出,y取值范围称为输出空间,但输出内容是固定长度的(字节序列长度固定)
- 输入是无穷个,但是固定字节的输出却能表示的状态是有限个
- 一定存在xm、xn经过hash函数算出的y值一样,把不同x值求得y值一样的情况称为hash冲突,它们发生碰撞
- hash算法设计还要兼顾高效
- hash不可逆,不能从结果反推出输入值,hash是单向散列算法,不可逆
- hash用在key的计算上
- x一个微小的变化,哪怕是一个bit位的变化,也将引起结果y巨大的变化

#### 2.2 常见算法

- SHA(Secure Hash Algorithm)安全散列算法,包含一个系列算法,分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512
  - 数字签名防篡改
- MD5(Message Digest Algorithm 5)信息摘要算法5,输出是128位。运算速度比SHA-1快
  - 用户密码存储
  - 上传、下载文件完整性校验
  - 大的数据的快速比对,例如字段很大,增加一个字段存储该字段的hash值,对比内容是否修改

```go
package main
import (
 "fmt",
 "crypto/sha256"
)
func main() {
    h := sha256.New()
    // 通过Write方法添加数据
    h.Write([]byte("abc"))
    // 计算并返回当前的哈希值,返回字节切片
    // 参数可以在已有数据的后面追加内哦让那个再进行哈希计算,如果我们希望直接获取当前数据的哈希值,并不需要追加内容,这时就要传入nil(没有追加内容)
    r := h.Sum(nil)
    // 把字节序列r的每个字节以16进制显示
    s := fmt.Sprint("%x", r) 
    fmt.Printf("%T %s %d\n", r, s, len(s))
}
```

#### 2.3 内存模型

map采用哈希表实现。Go的map类型也是引用类型,有一个标头值hmap,指向一个底层的哈希表

哈希表Hash Table

- 简单理解公式为y=hash(x)
- 开辟一块内存空间,分割出一个个房间,这个"房间"称为bucket桶,按照y值为"房间"编号
- 使用给出的x计算出对应的y值,可以按照某种关系计算出数据将被存储到的"房间号码",将数据存入该房间
- 即使是hash函数设计的好,数据分布均匀,但是存储的数据很多(超过负载因子),则需要扩容,否则再加入数据后,冲突太多,引起效率低下

理解hash函数原理,可以用除留余数法来思考,即hash(x) = key mod p。p是hash表大小,看做房间个数

hash(x0) => Roomk,计算出一个确定的房间号码

#### 2.4 应用

##### 2.4.1 初始化

```go
var m1 map[string]int // nil, 很危险。map不是零值可用
fmt.Println(m1, m1 == nil)
m1["t"] = 200 // panic, 不可以, 需要初始化才可以
// 初始化方式一:
var m0 = map[string]int{} // 安全,没有一个键值对而已
var m1 = map[string]int{
    "a": 11,
    "b": 22,
    "c": 33
}
// 初始化方式二:
var m2 = make(map[int]string) // 一个比较小的起始空间大小
m2[100] = "abc"
m3 := make(map[int]string, 100) // 分配足球容量来容纳100个元素,长度为0。为了减少扩容,可以提前给出元素个数
```

##### 2.4.2 新增或修改

```go
var m = make(map[string]int)
m["a"] = 11 // key不存在,则创建新的key和value对
m["a"] = 22 // key已经存在,则覆盖value
```

##### 2.4.3 查找

- 使用map一般需要使用key来查找,时间复杂度为O(1)

```go
fmt.Println(m["a"])
fmt.Println(m["b"])
if _, ok := m["b"]; !ok {
    fmt.Println("不存在")
}
```

key访问map最高效的方式

##### 2.4.4 长度

```go
len(m) // 返回kv对的个数
```

> 注意: 由于map的特殊构造,不能使用cap

##### 2.4.5 移除

```go
delete(m, "a") // 存在,删除kv对
delete(m, "b") // 不存在,删除操作也不会panic
```

##### 2.4.6 遍历

```go
var m = map[string]int{
    "a":11,
    "b":22,
    "c":33
}
for k,v := range m {
    fmt.Println(k, v)
}
```

> 注意: map的key是无序的,千万不要从遍历结果来推测其内部顺序

### 3.哈希表原理

y = hash(x)

- 内存是线性编址的,容器都要划分格子房间,每个房间占用的字节数一样多,每一个房间编房号
- hash(key) => room no, 通过一个简单的固定步数计算公式既可以定位存储的内存地址对应的空间
- 存储键值对有可能出现hash冲突,可以采取下列解决方案
  - 开地址法,本房间有人占了,你去其他地方
  - 拉链法,本房间有人占了,使用链表尾部追加。go采用拉链法,但是有改进
- 查询
  - 用key查,hash(key)算出房间号,映射到内存地址,步骤是固定的四则运算,O(1)
  - map应该使用key来查询才是最有效率的
  - 如果使用value来查找,因为这是遍历,后果自负,O(n)







